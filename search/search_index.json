{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>DCPL (pronounced \"disciple\", standing for duty, claim, power, claim and liability, or digital contracts programming language) is a domain specific language that serves as an information model for specififying norms. As discussions on several aspects of normative concepts and normative systems are still open in the literature, DCPL (at first named DPCL) attempts to remain as much as neutral with respect to the actual semantics, yet aims to provide a minimal common ground to encode normative computational artefacts.</p> <p>Warning</p> <p>This documentation is a work in progress and might contain some inaccuracies.</p>"},{"location":"index.html#comparison-with-other-norm-specification-languages","title":"Comparison with other norm-specification languages","text":"<ul> <li>DCPL like ODRL aims to provive primarily an informational model, and is JSON-centred, but DCPL include power categories, and focuses on normative mechanisms (it does not include inherently concepts as assets);</li> <li>DCPL like FLINT/eFLINT takes as primitives frames constructs from Hohfeld's framework of normative concepts, but DCPL strictly separates conditional from normative aspects, and allow specifying a wider array of normative concepts;</li> <li>DCPL like Logical English takes as primitives transformational and reactive rules to deal with conditional aspects, but DCPL includes explicit normative concepts.</li> </ul>"},{"location":"index.html#references","title":"References","text":"<ul> <li>Sileno, G., van Binsbergen, T., Pascucci, M., van Engers, T.,   DPCL: a Language Template for Normative Specifications,   Workshop on Programming Languages and the Law (ProLaLa 2022), co-located with POPL 2022   https://arxiv.org/abs/2201.04477</li> </ul>"},{"location":"installation.html","title":"Installation","text":"<p>Warning</p> <p>DCPL is still under development and does not have an interpreter yet.</p>"},{"location":"examples/comparison-odrl.html","title":"Comparison with ODRL","text":"<p>In this section, we provide a practical comparison between DCPL and ODRL. We propose use-case examples that highlight the differences in their design, and provide implementations for both ODRL and DCPL to discuss the syntax.</p> <p>Info</p> <p>Use-cases, ODRL examples, and discussion points in this section have been extracted from the paper A critical reflection on ODRL by M. G. Kebede et al. (full reference here).</p>"},{"location":"examples/comparison-odrl.html#delegation","title":"Delegation","text":"<p>Data-sharing scenarios, at times, require individuals to act on behalf of another. For example, a guardian may be required to act on behalf of a minor; or a carer on behalf of a person unable to grant or deny access to data. Similar patterns occur at the level of institutes. Additionally, research institutes might grant rights to be used by partner institutes under certain conditions to promote a shared research goal.</p>"},{"location":"examples/comparison-odrl.html#example-medical-data-sharing","title":"Example: Medical Data-Sharing","text":"<p>Suppose <code>OrganizationX</code>, an institution in the Netherlands maintaining a registry of patient data, forms a data-sharing agreement with <code>OrganizationY</code>, an institution in Belgium. The data-sharing agreement grants <code>OrganizationY</code> the permission to access the data and the possibility of delegating this permission to a third party, OrganizationZ. Consequently, the latter will be allowed to have access to the data if <code>OrganizationY</code> decides to delegate the permission received from <code>OrganizationX</code>.</p> <p>In ODRL we would model this with an <code>agreement</code>:</p> <pre><code>{\n  \"@type\": \"agreement\",\n  \"permission\": {\n    \"assigner\": \"OrganizationX\",\n    \"assignee\": \"OrganizationY\",\n    \"action\": \"transfer\",\n    \"target\": \"datasetA\"\n  }\n}\n</code></pre> <p>Here, ownership is assumed to include the possibility of transferring the asset again to someone else (e.g., <code>OrganizationZ</code>). This model can be used as a speci\ufb01cation for non-monotonic delegation, where the grantor loses the permission delegated. However, the same model can not be used to specify monotonic delegation scenarios where the grantor maintains the delegated permission.</p> <p>This especially becomes problematic to capture the power relationship between parties; e.g., the party in power has to maintain ownership of the asset, or \u201cveto\u201d power to either constrain or revoke granted rights, as well as the power to transfer and/or lose ownership of the asset entirely. For these limitations, we consider the following alternative model:</p> <pre><code>[\n  {\n    \"@type\": \"agreement\",\n    \"permission\": {\n      \"assigner\": \"OrganizationX\",\n      \"assignee\": \"OrganizationY\",\n      \"action\": \"grantUse\",\n      \"target\": \"datasetA\",\n      \"duty\": [{ \"action\": \"nextPolicy\", \"target\": \"ex:newPolicy\" }]\n    }\n  },\n  {\n    \"@type\": \"set\",\n    \"uid\": \"ex:newPolicy\",\n    \"permission\": [{ \"action\": \"read\", \"target\": \"datasetA\" }]\n  }\n]\n</code></pre> <p>In this way, however, usage rights are restricted only to a third party and not further. In some cases, delegated parties need to be allowed to delegate. A possible model (possibly abusing the intended use of grantUse) would be the one expressed below:</p> <pre><code>[\n  {\n    \"@type\": \"agreement\",\n    \"permission\": {\n      \"assigner\": \"OrganizationX\",\n      \"assignee\": \"OrganizationY\",\n      \"action\": \"grantUse\",\n      \"target\": \"datasetA\",\n      \"duty\": [{ \"action\": \"nextPolicy\", \"target\": \"ex:newGrantPolicy\" }]\n    }\n  },\n  {\n    \"@type\": \"set\",\n    \"uid\": \"ex:newGrantPolicy\",\n    \"permission\": {\n      \"action\": \"grantUse\",\n      \"target\": \"datasetA\",\n      \"duty\": [{ \"action\": \"nextPolicy\", \"target\": \"ex:newPolicy\" }]\n    }\n  },\n  {\n    \"@type\": \"set\",\n    \"uid\": \"ex:newPolicy\",\n    \"permission\": [{ \"action\": \"read\", \"target\": \"datasetA\" }]\n  }\n]\n</code></pre> <p>This extension may enable us to form a hierarchical structure one step further than the previous example, yet it can not represent the full transfer of delegating power to a chain of delegators of unspeci\ufb01ed length.</p> <p>Other relevant aspects of delegation, e.g. the revocation of rights, also can not be speci\ufb01ed within ODRL. While expressions in ODRL provide terms for specifying deadlines or expiration dates using the constraint class, updating activities are not considered.</p> <p>In DCPL, unbound delegation to an entire class of agents can be expressed fully by the following.</p> <p>We first define a <code>power</code> for every <code>organization</code> agent to perform an action <code>#share</code> on some <code>dataset</code> which they have access too (i.e. <code>holder.dataset</code>) to some <code>beneficiary</code> which is also an <code>organization</code>. The consequence of this action is that the object <code>sharing</code> becomes active with the given parameters.</p> CodeJSON <pre><code>power {\n    holder: organization\n    action: #share {\n        dataset: holder.dataset\n        beneficiary: organization\n    }\n    consequence: +sharing {\n        grantor: holder\n        beneficiary: action.beneficiary\n        dataset: action.dataset\n    }\n}\n</code></pre> <pre><code>{\n\"position\": \"power\",\n\"holder\": \"organization\",\n\"action\": {\n    \"reference\": \"#share\",\n    \"refinement\": {\n    \"dataset\": \"holder.dataset\",\n    \"beneficiary\": \"organization\"\n    }\n},\n\"consequence\": {\n    \"plus\": {\n    \"reference\": \"sharing\",\n    \"refinement\": {\n        \"grantor\": \"holder\",\n        \"beneficiary\": \"action.beneficiary\",\n        \"dataset\": \"action.dataset\"\n    }\n    }\n}\n}\n</code></pre> <p>Note</p> <p>There is an implicit condition for the action <code>#share</code> to be performed and it depends on the descriptor <code>holder.dataset</code>.</p> <p>Then we define the concept of <code>sharing</code> with a composite object:</p> <ul> <li>We activate a <code>liberty</code> for the <code>beneficiary</code> to <code>#read</code> the <code>dataset</code>.</li> <li>We define a new <code>power</code> for the <code>beneficiary</code> to also perform the action <code>#share</code>, but only on this specific dataset.</li> </ul> CodeJSON <pre><code>sharing(grantor, beneficiary, dataset) {\n    liberty {\n        holder: beneficiary\n        counterparty: grantor\n        action: #read {\n            dataset: dataset\n        }\n    }\n\n    power {\n        holder: beneficiary\n        action: #share {\n            dataset: dataset\n            beneficiary: organization\n        }\n        consequence: +sharing {\n            grantor: beneficiary\n            beneficiary: action.beneficiary\n            dataset: dataset\n        }\n    }\n}\n</code></pre> <pre><code>{\n\"compound\": \"sharing\",\n\"params\": [\"grantor\", \"beneficiary\", \"dataset\"],\n\"content\": [\n    {\n    \"position\": \"liberty\",\n    \"holder\": \"beneficiary\",\n    \"counterparty\": \"grantor\",\n    \"action\": {\n        \"reference\": \"#read\",\n        \"refinement\": {\n        \"dataset\": \"dataset\"\n        }\n    }\n    },\n    {\n    \"position\": \"power\",\n    \"action\": {\n        \"reference\": \"#share\",\n        \"refinement\": {\n        \"dataset\": \"dataset\",\n        \"beneficiary\": \"organization\"\n        }\n    },\n    \"consequence\": {\n        \"plus\": {\n        \"reference\": \"sharing\",\n        \"refinement\": {\n            \"grantor\": \"beneficiary\",\n            \"beneficiary\": \"action.beneficiary\",\n            \"dataset\": \"dataset\"\n        }\n        }\n    }\n    }\n]\n}\n</code></pre> <p>This not only allows for endless delegation chains, but also easily introduces the concept of revoking. We define a <code>power</code> for an <code>organization</code> agent to <code>#revoke_access</code> to the given <code>dataset</code> for any other organization currently sharing it (even indirectly), deactivating the <code>sharing</code> object.</p> CodeJSON <pre><code>power {\n    holder: organization\n    action: #revoke_access {\n        dataset: holder.dataset\n        beneficiary: organization\n    }\n    consequence: -sharing {\n        grantor: holder\n        beneficiary: action.beneficiary\n        dataset: action.dataset\n    }\n}\n</code></pre> <pre><code>{\n    \"position\": \"power\",\n    \"holder\": \"organization\",\n    \"action\": {\n        \"reference\": \"#share\",\n        \"refinement\": {\n            \"dataset\": \"holder.dataset\",\n            \"beneficiary\": \"organization\"\n        }\n    },\n    \"consequence\": {\n        \"minus\": {\n            \"reference\": \"sharing\",\n            \"refinement\": {\n                \"grantor\": \"holder\",\n                \"beneficiary\": \"action.beneficiary\",\n                \"dataset\": \"action.dataset\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"examples/comparison-odrl.html#semantic-for-duty","title":"Semantic for Duty","text":"<p>Duty in its common legal sense is an action that an agent is obliged to do; otherwise, there will be a violation (see, e.g., Hohfeld\u2019s framework of primitive legal concepts<sup>1</sup>).</p>"},{"location":"examples/comparison-odrl.html#example-compensation","title":"Example: Compensation","text":"<p>In ODRL we could model a simple compensation agreement as following:</p> <pre><code>{\n  \"@type\": \"agreement\",\n  \"obligation\": {\n    \"assigner\": \"OrganizationX\",\n    \"assignee\": \"OrganizationZ\",\n    \"action\": \"compensate\",\n    \"refinement\": {\n      \"leftoperand\": \"payAmount\",\n      \"operator\": \"eq\",\n      \"rightOperand\": { \"@value\": \"2000.00\", \"@type\": \"xsd:decimal\" },\n      \"unit\": \"http://dbpedia.org/resource/Euro\"\n    }\n  }\n}\n</code></pre> <p>But, the concept of duty is repurposed even for Hohfeld's institutional power when acquiring a permission:</p> <pre><code>{\n  \"@type\": \"agreement\",\n  \"permission\": {\n    \"assigner\": \"OrganizationX\",\n    \"assignee\": \"OrganizationY\",\n    \"action\": \"use\",\n    \"target\": \"datasetA\",\n    \"duty\": {\n      \"action\": \"pay\",\n      \"refinement\": {\n        \"leftoperand\": \"payAmount\",\n        \"operator\": \"eq\",\n        \"rightoperand\": { \"@value\": \"500.00\", \"@type\": \"xsd:decimal\" },\n        \"unit\": \"http://dbpedia.org/resource/Euro\"\n      }\n    }\n  }\n}\n</code></pre> <p>This ambiguity is resolved in DCPL with the support for all Hohfeld's normative positions. In practice, we can rewrite the first policy as following:</p> CodeJSON <pre><code>duty {\n    holder: organization_z\n    counterparty: organization_x\n    action: #compensate {\n        amount: 2000.0\n        unit: \"http://dbpedia.org/resource/Euro\"\n    }\n}\n</code></pre> <pre><code>{\n    \"position\": \"duty\",\n    \"holder\": \"organization_z\",\n    \"counterparty\": \"organization_x\",\n    \"action\": {\n        \"reference\": \"#compensate\",\n        \"refinement\": {\n            \"amount\": 2000.0,\n            \"unit\": \"http://dbpedia.org/resource/Euro\"\n        }\n    }\n}\n</code></pre> <p>And the second one as following:</p> CodeJSON <pre><code>power {\n    holder: organization_y\n    action: #use {\n        dataset: dataset_a\n    }\n    consequence: +duty {\n        holder: organization_y\n        counterparty: organization_x\n        action: #compensate {\n            amount: 500.0\n            unit: \"http://dbpedia.org/resource/Euro\"\n        }\n    }\n}\n</code></pre> <pre><code>{\n    \"position\": \"power\",\n    \"holder\": \"organization_y\",\n    \"action\": {\n        \"reference\": \"#use\",\n        \"refinement\": {\n            \"dataset\": \"dataset_a\"\n        }\n    },\n    \"consequence\": {\n        \"position\": \"duty\",\n        \"holder\": \"organizatyon_y\",\n        \"counterparty\": \"organization_x\",\n        \"action\": {\n            \"reference\": \"#compensate\",\n            \"refinement\": {\n                \"amount\": 500.0,\n                \"unit\": \"http://dbpedia.org/resource/Euro\"\n            }\n        }\n    }\n}\n</code></pre> <p>Here we explicitate the holder of the <code>power</code>, <code>organization_y</code> has the institutional power to <code>#use</code> the <code>dataset_a</code> but this activates a <code>duty</code> to <code>#compensate</code>.</p>"},{"location":"examples/comparison-odrl.html#identification-of-parties","title":"Identification of Parties","text":""},{"location":"examples/comparison-odrl.html#transformational-rules","title":"Transformational Rules","text":""},{"location":"examples/comparison-odrl.html#conflict-resolution","title":"Conflict Resolution","text":""},{"location":"examples/comparison-odrl.html#modeling-outcomes","title":"Modeling Outcomes","text":""},{"location":"examples/comparison-odrl.html#modifying-rules","title":"Modifying Rules","text":""},{"location":"examples/comparison-odrl.html#actions","title":"Actions","text":""},{"location":"examples/comparison-odrl.html#policy-lify-cycle","title":"Policy Lify-Cycle","text":""},{"location":"examples/comparison-odrl.html#references","title":"References","text":"<ul> <li>Kebede, M. G., Sileno, G., &amp; van Engers, T. (2021). A Critical Reflection on ODRL. Lecture Notes in Computer Science (Including Subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics), 13048 LNAI, 48\u201361. https://doi.org/10.1007/978-3-030-89811-3_4</li> </ul> <ol> <li> <p>Hohfeld, W.N.: Fundamental legal conceptions as applied in judicial reasoning. Yale Law J. 26(8), 710\u2013770 (1917)\u00a0\u21a9</p> </li> </ol>"},{"location":"examples/library.html","title":"Library Regulation","text":"<p>Library regulation is a classic example used in the normative systems literature, and we will use it here as well to illustrate the main features of the language.</p> <ul> <li>Student or staff can register as member of the library by using their id card (example of act creating a new qualification).</li> </ul> <pre><code>power {\n    holder: student | staff\n    action: #register { instrument: holder.id_card }\n    consequence: holder in member\n}\n</code></pre> <ul> <li>Any member can borrow a book for at max 1 month (act creating a composite object).</li> </ul> <pre><code>power {\n    holder: member\n    action: #borrow { item: book }\n    consequence: +borrowing {\n        lender: library\n        borrower: holder\n        item: book\n        timeout: now() + 1m\n    }\n}\n</code></pre> <ul> <li>By borrowing, the borrower can be requested in any moment to return the item.   The borrower has the duty to return the item within the given date.   If the borrower does not return the item, they may be fined (example of composite object, with power, duty and violation constructs).</li> </ul> <pre><code>borrowing(lender, borrower, item, timeout) {\n    power {\n        holder: lender\n        action: #request_return\n        consequence: +duty {\n            holder: borrower\n            counterparty: lender\n            action: #return { item: book }\n        }\n    }\n    duty d1 {\n        holder: borrower\n        counterparty: lender\n        action: #return { item: book }\n        violation: now() &gt; timeout\n    }\n    +d1.violation =&gt; +power {\n        holder: lender\n        action: #fine\n        consequence: +fine(borrower, lender)\n    }\n}\n</code></pre>"},{"location":"reference/composite-objects.html","title":"Composite Objects","text":"<p>More complex institutional concepts (e.g., ownership) can be described as a composition of other directives. DCPL allows for combining the objects above into reusable, parameterizable compounds. All directives inside a composite object are defined as long as the object is active.</p>"},{"location":"reference/composite-objects.html#base-syntax","title":"Base Syntax","text":"<p>Composite objects have a function-like syntax, as they can receive any amount of parameters that are scoped to the object definition inside.</p> CodeJSON <pre><code>ownership(person, item) {\n    ...\n}\n</code></pre> <pre><code>{\n    \"compound\": \"ownership\",\n    \"args\": {\n        \"person\": \"person\",\n        \"item\": \"item\"\n    },\n    \"content\": []\n}\n</code></pre>"},{"location":"reference/composite-objects.html#parameter-descriptors","title":"Parameter Descriptors","text":"<p>For composite objects, parameters names act as descriptors by default, scoping the use of a composite object. However, the user can alias the internal reference to change its scoped reference name or to distinguish between the same descriptors.</p> CodeJSON <pre><code>under_examination(teacher: person, student: person) {\n    ...\n}\n</code></pre> <pre><code>{\n    \"compound\": \"under_examination\",\n    \"args\": {\n        \"teacher\": \"person\",\n        \"student\": \"person\"\n    },\n    \"content\": []\n}\n</code></pre>"},{"location":"reference/composite-objects.html#examples","title":"Examples","text":"<p>If there is nothing else than deontic and power frames in compounds, the institutional/non-institutional knowledge decomposition is evident. We could in principle use any other means (ontologies, logic programs, etc.) for the domain and/or terminological knowledge.</p> <p>Example</p> <p>We want to define a composite object that allows to model how <code>user</code> agents can block each other which deactivates their liberty to send and receive chat messages in both directions.</p> <pre><code>blocking(subject: user, blocked: user) {\n    -liberty {\n        holder: blocked,\n        action: #send_chat {\n            recipient: subject,\n            message: string\n        }\n    }\n    -liberty {\n        holder: subject,\n        action: #send_chat {\n            recipient: blocked,\n            message: string\n        }\n    }\n}\n</code></pre> <p>However, with the introduction of rules that are only evaluated while the object is active, we obtain a unique level of expressiveness.</p> <p>Example</p> <p>Here we define the concept of borrowing an item for a certain time:</p> <pre><code>borrowing(lender: person, borrower: person, book, timeout: number) {\n    power {\n        holder: lender\n        action: #request_return\n        consequence: +duty {\n            holder: borrower\n            counterparty: lender\n            action: #return { item: book }\n        }\n    }\n    duty d1 {\n        holder: borrower\n        counterparty: lender\n        action: #return { item: book }\n        violation: now() &gt; timeout\n    }\n    +d1.violation =&gt; +power {\n        holder: lender\n        action: #fine { recipient: borrower }\n        consequence: +angry(borrower, lender)\n    }\n}\n</code></pre>"},{"location":"reference/directives.html","title":"Directives","text":"<p>A DCPL program is a collection of directives. Each directive constitutes a definition statement for one of the following:</p> <ul> <li>Object</li> <li>Power Frame</li> <li>Deontic Frame</li> <li>Trasformational Rule</li> <li>Reactive Rule</li> <li>Composite Object</li> </ul>"},{"location":"reference/directives.html#overview","title":"Overview","text":"<p>The following diagram offers a UML-like view on DCPL information model.</p> <p></p>"},{"location":"reference/objects-and-events.html","title":"Objects &amp; Events","text":"<p>At a fundamental level, DCPL relies on the common-sensical distinction of objects (-types) from events (-types), an ontological ground confirmed e.g. in LKIF-core<sup>1</sup>.</p>"},{"location":"reference/objects-and-events.html#objects","title":"Objects","text":"<p>Objects are persistent data within a DCPL program instance and they are used to represent agents and facts about the state of the program. Everything that doesn\u2019t actively change the system is an object. All objects (including states) are denoted as literals (e.g. <code>user</code>). Objects can be active or inactive, allowing them to also be used as boolean expressions in rule conditions.</p>"},{"location":"reference/objects-and-events.html#descriptors","title":"Descriptors","text":"<p>Extensional semantics applied in formal languages are based on set-theory and consider classes or types as sets of instances. This means that they (theoretically) maintain access to an abstract data structure, used e.g. to enlist all instances, and then to check whether an instance belongs to it. Rather than sets of objects centrally maintained, DCPL considers the association of several descriptors to each object.</p> <p>As an analogy, consider how people generally keep in their own wallets id-cards, library cards, discount coupons, membership cards, etc. These are examples of several \u201cidentity\u201d certificates (unique or not) operational in different contexts, which have been issued by an authority, and of which no other copy may exist, except the one people keep with them.</p> <p>DCPL aims to bring the qualification act in the foreground, and it does so by means of the <code>is</code> and <code>becomes</code> operators.</p> <p>Example</p> <p>This is how we express that <code>card_holder</code> agents qualify as a <code>member</code>:</p> <pre><code>card_holder becomes member\n</code></pre> <p>While this is how we check that some <code>person</code> X is a <code>member</code>:</p> <pre><code>person_x is member\n</code></pre>"},{"location":"reference/objects-and-events.html#primitive-types","title":"Primitive Types","text":"<p>Supported primitive types are all descriptors, and their instances are automatically described with them:</p> <ul> <li><code>string</code> (e.g., <code>\"example\" is string</code>)</li> <li><code>number</code> (e.g., <code>42 is number</code>, <code>3.14 is number</code>)</li> <li><code>boolean</code> (i.e., <code>true is boolean</code> and <code>false is boolean</code>)</li> <li><code>undefined</code> (i.e., <code>undefined is undefined</code> )</li> </ul> <p>A primitive type instance (e.g. <code>42</code> or <code>\"urn:user:001\"</code>) also acts as a descriptor which represents the identity function for that value.</p>"},{"location":"reference/objects-and-events.html#object-properties","title":"Object Properties","text":"<p>Each object and each of its properties naturally act as a descriptor.</p> <p>Example</p> <p>A <code>dataset</code> A is considered to be owned by some <code>organization</code> X:</p> <pre><code>\"urn:org:x\" becomes organization\n\"urn:dataset:a\" becomes organization.dataset\n</code></pre>"},{"location":"reference/objects-and-events.html#set-operations","title":"Set Operations","text":"<p>Unions (using the OR operator <code>|</code>) and intersections (using the AND operator <code>&amp;</code>) of descriptors are also descriptors.</p> <p>Example</p> <p>Any agent which is either <code>student</code> or <code>staff</code> is also a <code>university_member</code>:</p> <pre><code>student | staff becomes university_member\n</code></pre> <p>A union descriptor can be expected to have only properties that are shared among all the descriptors. An intersection descriptor instead can be expected to have all the properties combined.</p>"},{"location":"reference/objects-and-events.html#agents","title":"Agents","text":"<p>An object becomes an agent when it is granted the ability to perform one or more actions (as discussed in normative positions). Agents will often act as specifiers, indicating the type or group of individuals that a frame attribute applies to.</p> <p>A special type of agent is <code>*</code>, which represents all agents.</p> <p>Example</p> <p>If a duty is held by the agent <code>teacher</code>, every agent that has the <code>teacher</code> descriptor has that duty.</p>"},{"location":"reference/objects-and-events.html#events","title":"Events","text":"<p>Events actively change the system (i.e. they represent a transition), and they are denoted with prefixed literals (e.g. <code>#borrow</code>). A special case of transition events are those concerning the creation or removal of objects. For instance, the activation of a raining state is denoted with <code>+raining</code>, whereas its disactivation as <code>-raining</code>.</p> <p>Tip</p> <p>When transient, events should rather be modeled as objects (e.g. <code>borrowing</code> or <code>raining</code>), to denote for their ongoing state.</p>"},{"location":"reference/objects-and-events.html#refinements","title":"Refinements","text":"<p>Objects and events can have internal properties that can be specified or refined via the program. For instance, an action could be specified further referring to the thematic roles of verbs used in linguistics (agent, patient, recipient, instrument, etc.).</p> <p>For the description of internal components, DCPL follows an object-access syntax. Possible internal properties may be accessed as in OOP (e.g. <code>user.online</code>).</p> <p>Example</p> <p>This is how we model that <code>person</code> objects should have a <code>spouse</code> property which is also a <code>person</code>:</p> <pre><code>person {\n    spouse: person\n}\n</code></pre> <p>However, to reify the informational model, certain objects (e.g. the normative positions) come with fixed parameters.</p> <ol> <li> <p>Hoekstra, R., Breuker, J., Di Bello, M., Boer, A., et al.: The LKIF core ontology of basic legal concepts. LOAIT 321, 43\u201363 (2007)\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/positions.html","title":"Normative Positions","text":"<p>Normative frames are a specific type of object, representing Hohfeld\u2019s framework of normative concepts<sup>1</sup> which includes 8 notions, distributed on 2 squares, concerning respectively deontic (or duty-related) and potestative (or power-related) directives.</p> Visualization of Hohfeld's framework for normative concepts <p>Similarly to eFLINT, these concepts corresponds in DCPL to object-types with certain fixed parameters (frames, or stereotypical knowledge constructs). Their instantiation, as that of any other object, can be conditioned by transformational or reactive rules.</p>"},{"location":"reference/positions.html#power-frames","title":"Power Frames","text":"<p>Powers specify an <code>action</code> and an optional <code>consequence</code> for that action, along with an optional <code>holder</code> of the power (i.e. the class of agents that may perform the <code>action</code>). A power frame can be of any of the following classes: <code>power</code>, <code>liability</code>, <code>disability</code>, and <code>immunity</code>; it has the following properties:</p> property type default description <code>holder</code> <code>agent</code> <code>*</code> the agent that detains the power <code>action</code> <code>event</code> <code>undefined</code> the action that the holder has power to perform <code>consequence</code> <code>directive</code> <code>undefined</code> a directive that is triggered when the action is performed <p>Example</p> <p>Agents that are <code>student</code> or <code>staff</code> can <code>#register</code> as <code>member</code> of the library by using their <code>id_card</code> (example of act creating a new descriptor qualification).</p> <pre><code>power {\n    holder: student | staff\n    action: #register { instrument: holder.id_card }\n    consequence: holder becomes member\n}\n</code></pre>"},{"location":"reference/positions.html#deontic-frames","title":"Deontic Frames","text":"<p>A deontic frame is an object which can be of any of the following classes: <code>duty</code>, <code>prohibition</code>,<code>liberty</code>,<code>claim</code>,<code>protection</code>, <code>no_claim</code>; it has the following properties:</p> property type default description <code>holder</code> <code>agent</code> <code>*</code> the agent to which the duty applies <code>counterparty</code> <code>agent</code> <code>*</code> the agent which is interested in the fulfillment of the duty <code>action</code> <code>event</code> <code>undefined</code> the action to perform in order to fulfill the duty <code>violation</code> <code>external_expression</code> <code>undefined</code> an expression to evaluate to determine when the duty is violated <p>All objects are here referred through descriptors, which can be complete or partial. The referring mechanism is similar to Cascading Style Sheets (CSS) in the sense that the refinement may reduce the number of objects to which the policy applies.</p> <p>Example</p> <p>By borrowing, the borrower can be requested in any moment to return the item. The borrower has the duty to return the item within the given date. If the borrower does not return the item, they may be fined (example of composite object, with power, duty and violation constructs).</p> <pre><code>duty {\n    holder: borrower\n    counterparty: lender\n    action: #return { item: book }\n    violation: now() &gt; timeout\n}\n</code></pre> <ol> <li> <p>Hohfeld, W.N.: Fundamental legal conceptions as applied in judicial reasoning. Yale Law J. 26(8), 710\u2013770 (1917)\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/rules.html","title":"Rules","text":"<p>DCPL considers the distinction of transformational and reactive rules, proceeding along LPS<sup>1</sup>.</p>"},{"location":"reference/rules.html#transformational-rules","title":"Transformational Rules","text":"<p>Transformational rules follow the template: <code>a -&gt; b</code>, meaning that if <code>a</code> holds, then <code>b</code> holds too. Interpreting the \u201cif\u201d as \u201cas long as\u201d, the transformation aspect (of <code>a</code> into <code>b</code>) becomes explicit.</p> <p>Example</p> <p>As long as deontic frame <code>d1</code> is violated, the following power holds.</p> <pre><code>+d1.violation =&gt; +power {\n    holder: lender\n    action: #fine\n    consequence: +fine(borrower, lender)\n}\n</code></pre>"},{"location":"reference/rules.html#reactive-rules","title":"Reactive Rules","text":"<p>Reactive rules in DCPL are in the form: <code>#f =&gt; #g</code>, meaning that the occurrence of a <code>#f</code> event triggers subsequently a <code>#g</code> event. Causal effects become explicit with production events.</p> <p>Example</p> <p>If it rains, the floor becomes wet.</p> <pre><code>#rain =&gt; +wet\n</code></pre> <ol> <li> <p>Kowalski, R., Sadri, F.: A logic-based framework for reactive systems. In: International Workshop on Rules and Rule Markup Languages for the Semantic Web. pp. 1\u201315. Springer (2012)\u00a0\u21a9</p> </li> </ol>"}]}